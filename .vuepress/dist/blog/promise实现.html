<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Promise实现 | Promise-学习笔记</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="从头开始总结学习笔记，包括但不限于javaScript基础、vue和react相关、node相关等，每天总结一点点，积少成多...">
    <link rel="preload" href="/assets/css/0.styles.d7697ce3.css" as="style"><link rel="preload" href="/assets/js/app.0ff5dc81.js" as="script"><link rel="preload" href="/assets/js/2.d723362d.js" as="script"><link rel="preload" href="/assets/js/18.493ef864.js" as="script"><link rel="prefetch" href="/assets/js/10.7978180b.js"><link rel="prefetch" href="/assets/js/11.866c4d1e.js"><link rel="prefetch" href="/assets/js/12.15df3a37.js"><link rel="prefetch" href="/assets/js/13.b26f751d.js"><link rel="prefetch" href="/assets/js/14.6153f36e.js"><link rel="prefetch" href="/assets/js/15.a83a313d.js"><link rel="prefetch" href="/assets/js/16.9c7cafe7.js"><link rel="prefetch" href="/assets/js/17.e67a2380.js"><link rel="prefetch" href="/assets/js/19.f751d5fe.js"><link rel="prefetch" href="/assets/js/20.c3db4d13.js"><link rel="prefetch" href="/assets/js/21.194b3dd3.js"><link rel="prefetch" href="/assets/js/22.b9268a22.js"><link rel="prefetch" href="/assets/js/23.4b50c43a.js"><link rel="prefetch" href="/assets/js/24.1caba7d4.js"><link rel="prefetch" href="/assets/js/25.00b304f9.js"><link rel="prefetch" href="/assets/js/26.baa29ae4.js"><link rel="prefetch" href="/assets/js/27.1d6caa69.js"><link rel="prefetch" href="/assets/js/28.f13b8f97.js"><link rel="prefetch" href="/assets/js/29.35001df3.js"><link rel="prefetch" href="/assets/js/3.c9f27b53.js"><link rel="prefetch" href="/assets/js/30.0369e63e.js"><link rel="prefetch" href="/assets/js/31.077d72a6.js"><link rel="prefetch" href="/assets/js/32.f757d02e.js"><link rel="prefetch" href="/assets/js/33.99b0885c.js"><link rel="prefetch" href="/assets/js/34.ee7e64a9.js"><link rel="prefetch" href="/assets/js/35.e026493d.js"><link rel="prefetch" href="/assets/js/4.0e3a0dc2.js"><link rel="prefetch" href="/assets/js/5.9fc64bd7.js"><link rel="prefetch" href="/assets/js/6.4b34c62a.js"><link rel="prefetch" href="/assets/js/7.784d2758.js"><link rel="prefetch" href="/assets/js/8.62757065.js"><link rel="prefetch" href="/assets/js/9.aec258ee.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d7697ce3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Promise-学习笔记</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://juejin.im/user/586687fe61ff4b006db52c79/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金专栏
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/chudongyang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/chudongyang/chudongyang.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客仓库
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/chudongyang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://juejin.im/user/586687fe61ff4b006db52c79/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金专栏
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/chudongyang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/chudongyang/chudongyang.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客仓库
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="GitHub" class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/chudongyang" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>small-ui 组件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/components/button.html" class="sidebar-link">按钮组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>javaScript相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/javaScript/basic.html" class="sidebar-link">js基础</a></li><li><a href="/javaScript/mackdown基础语法.html" class="sidebar-link">mackdown基础语法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>vue相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/basic.html" class="sidebar-link">什么是库？什么是框架</a></li><li><a href="/vue/comLibrary.html" class="sidebar-link">从零搭建 vue 组件库</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>react相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/basic.html" class="sidebar-link">react基础</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>小程序</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wechat/error.html" class="sidebar-link">常见小程序错误的处理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>TypeScript相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TypeScript/basic.html" class="sidebar-link">ts-简介</a></li><li><a href="/TypeScript/数据类型.html" class="sidebar-link">ts-数据类型</a></li><li><a href="/TypeScript/函数.html" class="sidebar-link">ts-函数</a></li><li><a href="/TypeScript/类.html" class="sidebar-link">ts-类</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>flutter相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/flutter/install.html" class="sidebar-link">mac 下 fluter 的环境配置</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>指令相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/command/git.html" class="sidebar-link">git相关</a></li><li><a href="/command/npm.html" class="sidebar-link">npm相关</a></li><li><a href="/command/brew.html" class="sidebar-link">brew相关</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>数据库相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/db/MySQL.html" class="sidebar-link">mac下MySQL的安装</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>book相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/HTTP.html" class="sidebar-link">图解HTTP</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>博客文章</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/travis和vuepress搭建github仓库.html" class="sidebar-link">VuePress+Travis+Github搭建文档</a></li><li><a href="/blog/promise实现.html" class="active sidebar-link">Promise实现</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/事件环.html" class="sidebar-link">浏览器和Node事件环</a></li><li><a href="/blog/nodeJs流.html" class="sidebar-link">Node.js流</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="promise实现"><a href="#promise实现" class="header-anchor">#</a> Promise实现</h3> <img src="/promise.jpg" height="410" width="auto"> <p>摘要： 在很久很久以前，<code>Promise</code>还没有来到这个世上。那时森林里的有这样一群攻城狮，他们饱受回调地狱（回调金字塔）的摧残，苦不堪言。直到有一天，一位不愿意留下姓名的特工横空出世，将他们从回调地狱中解救了出来，代号<code>Promise</code>。自此，很多人都踏上了寻找<code>Promise</code>的道路，我亦如此...
<img src="https://user-gold-cdn.xitu.io/2018/7/28/164dec02da1bdbfe?w=82&amp;h=62&amp;f=gif&amp;s=129324" alt=""></p> <p>友情提醒： 本文使用ES6实现的<code>Promise</code>，不会的童鞋们请自行脑补！What？这位同学你竟然不知道ES6，好的，放学了请不要走，我们单独交流一下......</p> <h3 id="回调地狱-vs-promise"><a href="#回调地狱-vs-promise" class="header-anchor">#</a> 回调地狱 VS Promise</h3> <p>就拿<code>fs</code>（node的核心包）来说吧，假如我们需要同时请求<code>a.txt</code>和<code>b.txt</code>中的数据，然后对数据进行操作。这种需求在我们的开发中也经常遇到哦！</p> <ul><li>曾经的回调地狱</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let fs = require('fs');
let arr = [];
fs.readFile('a.txt','utf8',function(err,data){
  arr.push(data);
  fs.readFile('b.txt','utf8',function(err,data){
    arr.push(data);
    // 如果需要把更多的文件数据，那滋味不敢想象
    console.log(arr); 
  })
})
</code></pre></div><ul><li>现在的Promise</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let fs = require('fs');
function read(url,coding){ // 首先我们对fs.readFile()进行promise封装
  return new Promise((resolve,reject)=&gt;{
    fs.readFile(url,coding,function(err,data){
      if(err) reject(err);
      resolve(data);
    })
  })
}
Promise.all([read('a.txt','utf8'),read('b.txt','utf8')]).then(data=&gt;{
  // 这里我们就可以直接操作请求到的两个文件的数据了,Promise还很贴心的返回了一个数组
  console.log(data);  
})
</code></pre></div><p>相比较之下，<code>Promise</code>和回调地狱的战争起初就不是一个等级的呀，回调地狱听起来强大，但实则一点不经揍啊！<code>Promise</code>此时的内心应该是这样的：
<img src="https://user-gold-cdn.xitu.io/2018/7/28/164dec2c134f179b?w=140&amp;h=134&amp;f=jpeg&amp;s=5307" alt=""></p> <h3 id="promise之自己实现"><a href="#promise之自己实现" class="header-anchor">#</a> Promise之自己实现</h3> <p>看到这里，相信大家都很想知道Promise的核心实现是什么？接下来，请小伙伴们不要闭眼，看这里，看这里！我便说说我是如何在寻找<code>Promise</code>的道路上一条道走到黑的。（这标题起的，笑出猪叫声）</p> <h3 id="_1、promise-类封装"><a href="#_1、promise-类封装" class="header-anchor">#</a> 1、Promise 类封装</h3> <p>起初，我发现Promise是可以被new的，说明Promise 的出身是一个类啊，这可是一条很有价值的线索啊。（大家都知道，还用你说）</p> <div class="language- extra-class"><pre class="language-text"><code>class Promise {
  constructor(executor) { // executor是new Promise的参数
    this.status = 'pending'; // 保存状态
    this.reason = undefined; // 失败的原因
    this.value = undefined; // 成功的结果
    let resolve = (value)=&gt; {
      if(this.status === 'pending'){
        this.status = 'resolved';
        this.value = value;
      }
    }
    let reject = (reason)=&gt;{
      if(this.status === 'pending'){
        this.status = 'rejected';
        this.reason = reason;
      }
    }
    try {
      executor(resolve, reject); // 执行器       
    } catch (e) {
      reject(e);
    }
  }
  // 定义实例上的then方法，then调用的时候都是异步调用的 
  then(onFulfilled, onRejected) {
    if(this.status === 'resolved'){ // status状态改变时执行onFulFilled
      onFulfilled(this.value);
    }
    if(this.status === 'rejected'){ // status状态改变时执行onFulFilled
      onRejected(this.reason);
    }
  }
}  
</code></pre></div><p>这怎么仅仅一条线索就写出来这么东东呀，真让人摸不着头脑！别急，听我慢慢道来：</p> <ul><li><code>executor</code>：执行器，默认是new的时候就自动执行,executor的执行是同步的，为什么要try一下呢，executor执行时如果<code>throw new Error('error')</code>，直接走reject</li> <li><code>resolve, reject</code>：定义了<code>executor</code>的<code>resolve</code>成功的回调函数和<code>reject</code>失败的回调函数两个参数</li> <li><code>reason,value</code>：分别代表了成功返回的值和失败的原因</li> <li><code>status</code>：保存了<code>Promise</code>的三种状态<code>pending</code>（等待态），<code>fulfilled</code>(成功态)，<code>rejected</code>(失败态)
<ul><li>当一个<code>promise</code>的状态处于<code>pending</code>时，它可以过渡到<code>fulfilled</code>或者<code>ejected</code></li> <li>当一个promise的状态处于<code>fulfilled</code>时或者<code>rejected</code>时，不能再过渡到其他任何状态</li></ul></li> <li><code>then</code>函数： 因<code>Promise</code>是可以链式调用的，说明<code>then</code>函数是定义在<code>Promise</code>类的原型<code>Prototype</code>上的。</li></ul> <blockquote><p>这样我们就成功处理了同步情况下的<code>Promise</code>,是不是觉得自己已经追寻到<code>Promise</code>的终极力量了呢。（抽根烟，平复下躁动的心情）</p></blockquote> <p><img src="https://user-gold-cdn.xitu.io/2018/7/28/164e0356dc8a4c65?w=120&amp;h=117&amp;f=jpeg&amp;s=24937" alt=""></p> <h3 id="_2、promise异步的实现"><a href="#_2、promise异步的实现" class="header-anchor">#</a> 2、Promise异步的实现</h3> <p>在我们平时的开发中，往往异步代码比较多，异步执行需要，然<code>而Promise</code>的<code>executor</code>执行器又是同步执行的，它不等我们怎么办呢，好着急有木有。
我们在上面代码的基础上新增如下几行代码：</p> <div class="language- extra-class"><pre class="language-text"><code>class Promise {
  constructor(executor) {
    this.onResolvedCallbacks = []; // 保存成功的回调
    this.onRejectedCallbacks = []; // 保存失败的回调
    let resolve = (value)=&gt; {
      if(this.status === 'pending'){
        this.status = 'resolved';
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      }
    }
    let reject = (reason)=&gt;{
      if(this.status === 'pending'){
        this.status = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      }
    }
  }
  then(onFulfilled, onRejected) { 
    if(this.status === 'pending'){
      this.onResolvedCallbacks.push(()=&gt;{
          onFulfilled(this.value);
        });
      this.onRejectedCallbacks.push(()=&gt;{
          onRejected(this.reason);
        });
      });
    }
  }
}
</code></pre></div><p>当出现异步代码时，<code>status</code>的状态还是<code>pending</code>，我们可以先把<code>then</code>函数中成功和失败的回调保存下来，等到异步代码执行完成后，<code>status</code>的状态改变了，我们再去依次执行保存下来的回调函数。</p> <p>看到这里，如果觉得自己已经基本掌握<code>Promise</code>的实现，只能说尔等对<code>Promise</code>的核心力量一无所知。（别废话，赶紧写）好的，各位大佬！</p> <p><img src="https://user-gold-cdn.xitu.io/2018/7/28/164e04910a8a27e0?w=141&amp;h=53&amp;f=gif&amp;s=11155" alt=""></p> <h3 id="_3、promise之链式调用的实现"><a href="#_3、promise之链式调用的实现" class="header-anchor">#</a> 3、Promise之链式调用的实现</h3> <p>在开始实现之前呢，我们先来看一下如下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>//  这里的Promise是ES6封装好的，并不是我们自己实现的 
let promise = new Promise((resolve,reject)=&gt;{ 
  resolve('123');
})
let promise2 = promise.then((data)=&gt;{
  throw new Error('error');
})
promise2.then((data)=&gt;{
  console.log(data);
},(err)=&gt;{
  console.log(err); // 这里输出了error
})
</code></pre></div><blockquote><p>上面代码说明<code>then</code>函数执行后返回的<code>promise2</code>实例并不是<code>promise</code>实例，说明返回值不是<code>this</code>，因为<code>promise</code>不能即调用成功后不能再走失败，所以<code>then</code>函数执行后返回的<code>promise2</code>是一个新的<code>promise</code>实例。（跟jQuery的链式调用不一样哦）</p></blockquote> <p><code>Promise</code>的<code>constructor</code>的代码不需要改变，只需要对<code>then</code>函数进行再次封装：</p> <div class="language- extra-class"><pre class="language-text"><code>then(onFulfilled, onRejected) {
    // onFulfilled和onRejected可能没传
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value=&gt;value;
    onRejected = typeof onRejected === 'function' ? onRejected : (err)=&gt;{throw err};
    let promise2; // 需要每次调用then方法时，都需要返回新的promise
    promise2 = new Promise((resolve, reject)=&gt;{
      if(this.status === 'resolved'){
        setTimeout(()=&gt;{
          try {
            let x = onFulfilled(this.value); 
            // 执行完当前回调后返回的结果可能还是个promise
            resolvePromise(promise2,x,resolve, reject);
          } catch (e) {
            reject(e);
          }
        },0)
      }
      if(this.status === 'rejected'){
        setTimeout(()=&gt;{
          try {
            let x = onRejected(this.reason);
            resolvePromise(promise2,x,resolve, reject);
          } catch (e) {
            reject(e);
          }
        },0) 
      }
      if(this.status === 'pending'){
        this.onResolvedCallbacks.push(()=&gt;{
          setTimeout(()=&gt;{
            try {
              let x = onFulfilled(this.value);
              resolvePromise(promise2,x,resolve, reject);
            } catch (e) {
              reject(e);
            }
          },0)
        });
        this.onRejectedCallbacks.push(()=&gt;{
          setTimeout(()=&gt;{
            try {
              let x = onRejected(this.reason);
              resolvePromise(promise2,x,resolve, reject);
            } catch (e) {
              reject(e);
            }
          },0)
        });
      }
    })
    return promise2;
  }
</code></pre></div><ul><li><code>onFulfilled,onRejected</code>：当没有传的时候，需要做的处理</li> <li><code>promise2</code>：<code>then</code>函数的返回值是一个新的promise</li> <li><code>setTimeout</code>：(<a href="https://promisesaplus.com/" target="_blank" rel="noopener noreferrer">Promise/A+规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)要求<code>then</code>函数必须是异步的，当然原生的Promise实现并不是用的setTimeout，而是一个微任务</li> <li><code>resolvePromise</code>：封装<code>resolvePromise</code>方法，当then函数中的成功或者失败函数返回值x可能还是个promise</li></ul> <p>定义的resolvePromise方法：</p> <div class="language- extra-class"><pre class="language-text"><code>let resolvePromise = (promise2,x,resolve, reject)=&gt;{
  let called;
  // promise2和函数的返回值是同一个
  if(promise2 === x){
    return reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;'));
  }
  if(x!==null &amp;&amp; (typeof x === 'object' || typeof x === 'function')){
    try {
      let then = x.then;
      if(typeof then === 'function'){
        then.call(x,(y)=&gt;{
          if(called) return;
          called = true;
          resolvePromise(promise2,y,resolve, reject);// 递归处理，直到y是一个普通值
        },(err)=&gt;{
          if(called) return;
          called = true;
          reject(err);
        })
      }else{ // then如果是一个常量
        if(called) return;
        called = true;
        resolve(x);
      }
    } catch (e) {
      if(called) return;
      called = true;
      reject(e);
    }
  }else{ // x如果是一个常量
    if(called) return;
    called = true;
    resolve(x);
  }
}
</code></pre></div><ul><li>四个参数：<code>promise2</code> （then函数的返回值，是一个新的promise）
<code>x</code>（then中成功后者失败函数的返回值）<code>resolve</code>（promise2的resolve）<code>reject</code>（promise2的reject）</li> <li><code>called</code>： 加了<code>called</code>判断，防止多次调用，因为这里的逻辑不单单是自己的，还有别人的，别人的<code>promise</code>可能即会调用成功也会调用失败</li> <li><code>let then = x.then</code>：<code>x</code>可能还是一个<code>promise</code>，那么就让这个<code>Promise</code>执行</li></ul> <p>至此，我们终于追寻到了<code>promise</code>的核心力量所在。来，让我们小小的庆贺一下：
<img src="https://user-gold-cdn.xitu.io/2018/7/28/164e10d7fa8aa3ee?w=80&amp;h=65&amp;f=gif&amp;s=16293" alt=""></p> <h3 id="_3、promise之类上的方法实现"><a href="#_3、promise之类上的方法实现" class="header-anchor">#</a> 3、Promise之类上的方法实现</h3> <p>当然，我们已经初步了解了<code>promise</code>的核心力量，在我们开发的过程中，除了then方法，也会使用它的一些其他常用的方法，就像一位身经百战的特工，你除了会用刀，还要会用枪不是。我们在Promise类上定义它们：</p> <div class="language- extra-class"><pre class="language-text"><code>static resolve(value){
    return new Promise((resolve,reject)=&gt;{
      resolve(value);
    })
  }
  static reject(reason){
    return new Promise((resolve,reject)=&gt;{
      reject(reason);
    })
  }
  static all(promises){
    return new Promise((resolve,reject)=&gt;{
      let arr = [];
      let i = 0;
      let processData = (index,data)=&gt;{
        arr[index] = data;
        if(++i === promises.length){
          resolve(arr);
        }
      }
      for(let i = 0; i&lt; promises.length; i++){
        promises[i].then(data=&gt;{
          processData(i,data);
        },reject);
      }
    })
  }
  static race(promises){
    return new Promise((resolve,reject)=&gt;{
      for(let i = 0; i&lt; promises.length; i++){
        promises[i].then(resolve,reject);
      }
    })
  }
  catch(onRejected){
    return this.then(null,onRejected);
  }
</code></pre></div><blockquote><p>相信resolve，reject，all,race这四个类上的方法和catch这个原型的方法大家都已经很熟悉了，我就不过多的啰嗦了。</p></blockquote> <p>因为，我实在是编不下去了，我还有更重要的事情要去做：</p> <p><img src="https://user-gold-cdn.xitu.io/2018/7/28/164e1190f28b2b4f?w=198&amp;h=128&amp;f=jpeg&amp;s=6547" alt=""></p> <p>结语： 花了很久写的这篇文章，如果这篇文章令你或多或少有些收获，请不要吝啬你的赞美（点个赞再走吗，小哥哥小姐姐），如果有写的不对的地方，也希望各位大佬能不吝指教，万分感谢！原创文章，转载请注明出处！</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">9/15/2019, 4:29:22 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/travis和vuepress搭建github仓库.html" class="prev">
        VuePress+Travis+Github搭建文档
      </a></span> <span class="next"><a href="/blog/事件环.html">
        浏览器和Node事件环
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0ff5dc81.js" defer></script><script src="/assets/js/2.d723362d.js" defer></script><script src="/assets/js/18.493ef864.js" defer></script>
  </body>
</html>
