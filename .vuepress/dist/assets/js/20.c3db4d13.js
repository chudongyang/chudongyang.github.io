(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{674:function(e,t,v){"use strict";v.r(t);var o=v(49),_=Object(o.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h3",{attrs:{id:"浏览器和node事件环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器和node事件环"}},[e._v("#")]),e._v(" 浏览器和Node事件环")]),e._v(" "),v("img",{attrs:{src:"/eventloop.jpg",height:"410",width:"auto"}}),e._v(" "),v("p",[e._v("进入正文之前，首先要感谢各位大佬对本人第一篇掘金文章《"),v("a",{attrs:{href:"https://juejin.im/post/5b5b52dbe51d4534c34a4a6e",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES6版Promise实现，给你不一样的体验"),v("OutboundLink")],1),e._v("》的肯定及指正，可能写的不尽人意，但是你们的点赞会是我继续分享的动力之一，只要努力过，结果就不要太在意，因为努力之后的结果会让你满意！与诸位共勉！")]),e._v(" "),v("p",[e._v("好了，话不多说，接下来让我们进入今天的话题。今天我们来谈一谈事件环到底是什么？"),v("code",[e._v("javaScript")]),e._v("的事件环和"),v("code",[e._v("Node")]),e._v("的事件环有什么区别？有没有一种无从下手的感觉，别捉急，只要你仔细阅读本篇文章，相信能够解开心中的疑惑。\n"),v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/31/164f0edfde32d253?w=100&h=80&f=gif&s=35590",alt:""}})]),e._v(" "),v("h3",{attrs:{id:"先了解几组常见概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#先了解几组常见概念"}},[e._v("#")]),e._v(" 先了解几组常见概念")]),e._v(" "),v("p",[e._v("俗话说，工欲善其事必先利其器。在进入浏览器事件环和Node事件环情节之前呢，我们有必要了解以下几组常见的概念。")]),e._v(" "),v("ol",[v("li",[e._v("heap（堆）和 stack（栈）\n堆栈是在计算机领域不可忽视的概念，如果想要详细了解，请移步《"),v("a",{attrs:{href:"https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032",target:"_blank",rel:"noopener noreferrer"}},[e._v("堆栈_百度百科"),v("OutboundLink")],1),e._v("》。在javaScript中，栈中存的是基本数据类型，会自动分配内存空间，自动释放；堆中存的是引用数据类型，是动态分配的内存，大小不定也不会自动释放。")])]),e._v(" "),v("ul",[v("li",[v("code",[e._v("heap")]),e._v("堆：也可以叫堆内存；是一种队列优先，先进先出的数据结构；")]),e._v(" "),v("li",[v("code",[e._v("stack")]),e._v("栈：又名'堆栈',也是一种数据结构，不过它是按照先进后出原则存储数据的。\n"),v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/31/164f0a4b342417fa?w=1049&h=443&f=png&s=29234",alt:""}})])]),e._v(" "),v("blockquote",[v("p",[e._v("嘻嘻😝，自己花了半天时间（夸张）画得，自我感觉良好。")])]),e._v(" "),v("p",[e._v("既然我们大致理解了堆和栈的含义，我们来看一道面试题，如何用js代码实现队列和栈的功能呢？其实很简单啦，就是数组最基本常用的增删方法。")]),e._v(" "),v("ul",[v("li",[e._v("实现队列的方法（先进先出）")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let arr = new Array();\narr.push(1);\narr.push(2);\narr.shift();\n")])])]),v("ul",[v("li",[e._v("实现栈的方法（先进后出）")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let arr = new Array();\narr.push(1);\narr.push(2);\narr.pop();\n")])])]),v("ol",{attrs:{start:"2"}},[v("li",[e._v("线程和进程\n首先，我们应该知道进程比线程要大。一个程序至少要有一个进程，一个进程至少要有一个线程。就拿我们经常用的浏览器为例吧，为了更直观一些，先看下这张图片：")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/2/164f6492a3e468b6?w=532&h=408&f=png&s=23809",alt:""}}),e._v("\n由此可见，浏览器就是多进程的，当一个网页崩溃时不会影响其他网页的正常运行。我们主要了解下一下几个方面：")]),e._v(" "),v("ul",[v("li",[e._v("渲染引擎：渲染引擎内部是多线程的,内部包含了两个最重要的线程ui线程和js线程。这里要特别注意ui线程和js线程是互斥的,因为JS运行结果会影响到ui线程的结果。ui更新会被保存在队列中等到js线程空闲时立即被执行。")]),e._v(" "),v("li",[e._v("js单线程："),v("code",[e._v("JavaScript")]),e._v("最大的特点就是单线程的，其实应该说其主线程是单线程的。为什么这么说呢？你想一下，如果js是多线程的，我们在页面中这个线程要删了那个元素（不顺眼），另一个线程呢我要保留那个元素（我罩着的），这样岂不是就乱套了。这也是为什么"),v("code",[e._v("JavaScript")]),e._v("执行同步代码，异步代码并不会阻塞代码的运行。")]),e._v(" "),v("li",[e._v("其他线程：\n"),v("ul",[v("li",[e._v("浏览器事件触发线程(用来控制事件循环,存放"),v("code",[e._v("setTimeout")]),e._v("、浏览器事件、"),v("code",[e._v("ajax")]),e._v("的回调函数)")]),e._v(" "),v("li",[e._v("定时触发器线程("),v("code",[e._v("setTimeout")]),e._v("定时器所在线程)")]),e._v(" "),v("li",[e._v("异步HTTP请求线程("),v("code",[e._v("ajax")]),e._v("请求线程)")])])])]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[e._v("宏任务和微任务\n宏任务和微任务可以说都是异步任务。如果了解"),v("code",[e._v("vue")]),e._v("源码的同学，应该知道宏任务"),v("code",[e._v("macrotask")]),e._v("和微任务"),v("code",[e._v("microtask")]),e._v("这两个概念，他们的执行时机是不一样的。"),v("code",[e._v("vue")]),e._v("的"),v("code",[e._v("$nextTick")]),e._v("的源码就是通过宏任务和微任务实现的。(可以去"),v("a",{attrs:{href:"https://github.com/vuejs/vue/tree/dev/src/core/util",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue"),v("OutboundLink")],1),e._v("的github了解一下其实现原理)。")])]),e._v(" "),v("ul",[v("li",[e._v("常见的宏任务"),v("code",[e._v("macrotask")]),e._v("有："),v("code",[e._v("setTimeout")]),e._v("、"),v("code",[e._v("setInterval")]),e._v("、 "),v("code",[e._v("setImmediate")]),e._v("(ie浏览器才支持,node中自己也实现了)、"),v("code",[e._v("MessageChannel")])]),e._v(" "),v("li",[e._v("常见的微任务"),v("code",[e._v("microtask")]),e._v("有："),v("code",[e._v("promise.then()")]),e._v("、"),v("code",[e._v("process.nextTick")]),e._v("(node的)")])]),e._v(" "),v("h3",{attrs:{id:"javascript的事件环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript的事件环"}},[e._v("#")]),e._v(" javaScript的事件环")]),e._v(" "),v("p",[e._v("浏览器中，事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环，我们可以看下面这张图理解一下：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/2/164f63da02998416?w=638&h=359&f=jpeg&s=49329",alt:""}})]),e._v(" "),v("blockquote",[v("p",[e._v("从图中可以看出，同步任务会进入执行栈，而异步任务会进入任务队列（callback queue）等待执行。一旦执行栈中的内容执行完毕，就会读取任务队列中等待的任务放入执行栈开始执行。（图中缺少微任务）")])]),e._v(" "),v("p",[e._v("那么，我们来道面试题检验一下，当我们在浏览器中运行下面的代码，输出的结果是什么呢？")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("setTimeout(() => {\n    console.log('setTimeout1');\n    Promise.resolve().then(data => {\n        console.log('then3');\n    });\n},1000);\nPromise.resolve().then(data => {\n    console.log('then1');\n});\nPromise.resolve().then(data => {\n    console.log('then2');\n    setTimeout(() => {\n        console.log('setTimeout2');\n    },1000);\n});\nconsole.log(2);\n// 输出结果：2 then1 then2 setTimeout1  then3  setTimeout2\n")])])]),v("blockquote",[v("ol",[v("li",[e._v("先执行栈中的内容，也就是同步代码，所以2被输出出来；")]),e._v(" "),v("li",[e._v("然后清空微任务，所以依次输出的是 "),v("code",[e._v("then1")]),e._v(" "),v("code",[e._v("then2")]),e._v("；")]),e._v(" "),v("li",[e._v("因代码是从上到下执行的，所以1s后 "),v("code",[e._v("setTimeout1")]),e._v(" 被执行输出；")]),e._v(" "),v("li",[e._v("接着再次清空微任务，"),v("code",[e._v("then3")]),e._v("被输出；")]),e._v(" "),v("li",[e._v("最后执行输出"),v("code",[e._v("setTimeout2")])])])]),e._v(" "),v("h3",{attrs:{id:"node的事件环"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node的事件环"}},[e._v("#")]),e._v(" Node的事件环")]),e._v(" "),v("p",[v("code",[e._v("Node")]),e._v("是基于V8引擎的"),v("code",[e._v("JavaScript")]),e._v("运行环境，在处理高并发、I/O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。Node的事件环机制与浏览器的是不太一样。\n在Node运行环境中：")]),e._v(" "),v("ol",[v("li",[e._v("我们写的js代码会交由V8引擎进行处理")]),e._v(" "),v("li",[e._v("代码中可能会调用NodeApi，node会交由"),v("code",[e._v("libuv")]),e._v("处理")]),e._v(" "),v("li",[v("code",[e._v("libuv")]),e._v("通过阻塞I/O和多线程实现异步I/O")]),e._v(" "),v("li",[e._v("然后通过事件驱动的方式，将结果放到事件队列中，最终交给我们的应用。")])]),e._v(" "),v("p",[e._v("其实本质是在"),v("code",[e._v("libuv")]),e._v("(一个高性能的，事件驱动的I/O库)内部有这样一个事件环机制。在Node启动时会初始化事件环，话不多说，先上图：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/4/165058b12d81586b?w=614&h=673&f=png&s=55350",alt:""}}),e._v("\n图中显示的每个阶段都对应一个事件队列，当"),v("code",[e._v("event loop")]),e._v("执行到某个阶段时会将当前阶段对应的队列依次执行。当队列执行完毕或者执行数量超过上限时，才会转入下一个阶段。node中的微任务在切换队列时执行。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("timers")]),e._v("计时器：执行"),v("code",[e._v("setTimeout")]),e._v("、"),v("code",[e._v("setInterval")]),e._v("的回调函数；")]),e._v(" "),v("li",[v("code",[e._v("I/O callbacks")]),e._v("：执行"),v("code",[e._v("I/O callback")]),e._v("被延迟到下一阶段执行；")]),e._v(" "),v("li",[v("code",[e._v("idle, prepare")]),e._v("：队列的移动，仅内部使用")]),e._v(" "),v("li",[v("code",[e._v("poll")]),e._v("轮询：检索新的I/O事件;执行I/O相关的回调")]),e._v(" "),v("li",[v("code",[e._v("check")]),e._v("：执行"),v("code",[e._v("setImmediate")]),e._v("回调")]),e._v(" "),v("li",[v("code",[e._v("close callbacks")]),e._v("：执行"),v("code",[e._v("close")]),e._v("事件的"),v("code",[e._v("callback")]),e._v("，例如"),v("code",[e._v('socket.on("close",func)')])])]),e._v(" "),v("p",[e._v("好了，接下来我们先来看一道简单的测试题：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("setTimeout(function () {\n    console.log('setTimeout');\n});\nsetImmediate(function () {\n    console.log('setImmediate');\n});\n")])])]),v("blockquote",[v("p",[e._v("这道题中如果你在"),v("code",[e._v("node")]),e._v("环境中多运行几次，就会发现输出顺序是不固定的。也就是说虽然上图中"),v("code",[e._v("timers")]),e._v("队列在"),v("code",[e._v("check")]),e._v("队列前面，但是"),v("code",[e._v("setTimeout")]),e._v("和"),v("code",[e._v("setImmediate")]),e._v("没有明确的先后顺序的，这是由"),v("code",[e._v("node")]),e._v("的准备时间（准备工作会浪费一定的时间）导致的。")])]),e._v(" "),v("p",[e._v("对应上面这道练习题，我们再来看下面这道题：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("let fs = require('fs');\nfs.readFile('./1.txt', function () {\n    setTimeout(() => {\n        console.log('setTimeout');\n    }, 0);\n    setImmediate(() => {\n        console.log('setImmediate');\n    });\n});\n")])])]),v("blockquote",[v("p",[e._v("这道题的输出顺序是"),v("code",[e._v("setImmediate")]),e._v("然后"),v("code",[e._v("setTimeout")]),e._v("，无论你运行多少次，结果顺序不会发生改变。这是因为"),v("code",[e._v("fs")]),e._v("文件操作（I/O操作）属于属于"),v("code",[e._v("poll")]),e._v("阶段，"),v("code",[e._v("poll")]),e._v("阶段的下一阶段就是"),v("code",[e._v("check")]),e._v("阶段，所以输出顺序是毋庸置疑的。")])]),e._v(" "),v("p",[e._v("最后，让我们来再看一道面试题加深对Node事件环的理解：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("setImmediate(() => {\n    console.log('setImmediate1');\n    setTimeout(() => {\n        console.log('setTimeout1')\n    }, 0);\n});\nPromise.resolve().then(res=>{\n    console.log('then');\n})\nsetTimeout(() => {\n    process.nextTick(() => {\n        console.log('nextTick');\n    });\n    console.log('setTimeout2');\n    setImmediate(() => {\n        console.log('setImmediate2');\n    });\n}, 0);\n")])])]),v("blockquote",[v("p",[e._v("这道题的输出顺序是："),v("code",[e._v("then、setTimeout2、nextTick、setImmediate1、setImmediate2、setTimeout1")]),e._v("，为什么是这样的顺序呢？微任务"),v("code",[e._v("nextTick")]),e._v("的输出是因为"),v("code",[e._v("timers")]),e._v("队列切换到"),v("code",[e._v("check")]),e._v("队列，"),v("code",[e._v("setImmediate1")]),e._v("和"),v("code",[e._v("setImmediate2")]),e._v("连续输出是因只有当前队列执行完毕后才能进去下一对列。")])]),e._v(" "),v("p",[e._v("总结：今天的话题就先到这里了。可能本文有表述不清楚或者理解不对的地方，还请各位大佬给予指正，我会继续努力每周分享，万分感谢！如果您觉得看了这篇文章有所收获，请不要忘了动动手指点个小❤️哦！让我们一起荡起双桨，每天进步一点点，在技术的道路上越走越远！\n"),v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/5/16505b27e9e0d02b?w=240&h=240&f=jpeg&s=68812",alt:""}})]),e._v(" "),v("blockquote",[v("p",[e._v("原创不易，转载请注明出处！谢谢！")])])])}),[],!1,null,null,null);t.default=_.exports}}]);