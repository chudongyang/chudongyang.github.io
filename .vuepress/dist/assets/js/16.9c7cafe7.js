(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{677:function(t,a,e){"use strict";e.r(a);var s=e(49),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"ts-类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ts-类"}},[t._v("#")]),t._v(" ts-类")]),t._v(" "),e("p",[t._v("类是ES6新增加的语法，ts不仅实现了所有ES6中的类的功能外，还新增加了许多其他的功能。")]),t._v(" "),e("h3",{attrs:{id:"类的概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类的概念"}},[t._v("#")]),t._v(" 类的概念")]),t._v(" "),e("ul",[e("li",[t._v("类(Class)：定义了一件事物的抽象特点，包含它的属性和方法")]),t._v(" "),e("li",[t._v("对象（Object）：类的实例，通过 "),e("code",[t._v("new")]),t._v(" 生成")]),t._v(" "),e("li",[t._v("面向对象（OOP）的三大特性：封装、继承、多态")]),t._v(" "),e("li",[t._v("封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据")]),t._v(" "),e("li",[t._v("继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性")]),t._v(" "),e("li",[t._v("多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 "),e("code",[t._v("Cat")]),t._v(" 和 "),e("code",[t._v("Dog")]),t._v(" 都继承自 "),e("code",[t._v("Animal")]),t._v("，但是分别实现了自己的 "),e("code",[t._v("eat")]),t._v(" 方法。此时针对某一个实例，我们无需了解它是 "),e("code",[t._v("Cat")]),t._v(" 还是 "),e("code",[t._v("Dog")]),t._v("，就可以直接调用 "),e("code",[t._v("eat")]),t._v(" 方法，程序会自动判断出来应该如何执行 "),e("code",[t._v("eat")])]),t._v(" "),e("li",[t._v("存取器（getter & setter）：用以改变属性的读取和赋值行为")]),t._v(" "),e("li",[t._v("修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 "),e("code",[t._v("public")]),t._v(" 表示公有属性或方法")]),t._v(" "),e("li",[t._v("抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现")]),t._v(" "),e("li",[t._v("接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口")])]),t._v(" "),e("h3",{attrs:{id:"js中类的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js中类的使用"}},[t._v("#")]),t._v(" js中类的使用")]),t._v(" "),e("p",[t._v("ES6中，我们构造一个类需要遵循如下规则：")]),t._v(" "),e("ul",[e("li",[t._v("使用 "),e("code",[t._v("class")]),t._v(" 关键字定义类，使用 "),e("code",[t._v("constructor")]),t._v(" 定义构造函数")]),t._v(" "),e("li",[t._v("使用 "),e("code",[t._v("new")]),t._v(" 关键字生成一个类的实例")]),t._v(" "),e("li",[t._v("使用 "),e("code",[t._v("extends")]),t._v(" 继承父类，子类在 "),e("code",[t._v("constructor")]),t._v(" 构造函数中调用 "),e("code",[t._v("super()")]),t._v(" 关键字来调用父类的属性和方法")]),t._v(" "),e("li",[t._v("使用存取器 "),e("code",[t._v("getter")]),t._v(" 和 "),e("code",[t._v("setter")]),t._v(" 改变属性的赋值和读取行为")]),t._v(" "),e("li",[t._v("使用 "),e("code",[t._v("static")]),t._v(" 修饰符来定义一个静态方法，直接通过类来调用")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Animal{\n\tconstructor(name) {\n\t\tthis.name = name\n\t}\n\teat(food) {\n\t\tconsole.log(`${this.name} like to eat ${food}`)\n\t}\n\tstatic say() {\n\t\tconsole.log('hello world')\n\t}\n}\n")])])]),e("p",[t._v("ES7提案在ES6的基础上对类又进行了扩展，ts同样也很好的实现了它们。")]),t._v(" "),e("ul",[e("li",[t._v("ES7提案在类的最顶层，可以直接定义实例的属性，看起来比较整齐")]),t._v(" "),e("li",[t._v("ES7提案中使用 "),e("code",[t._v("static")]),t._v(" 定义静态属性，直接通过类来调用")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Animal{\n\tname = '我是实例的属性'\n\tconstructor(name) {\n\t\t...\n\t}\n\tstatic staticProp = '我是一个静态属性'\n}\n")])])]),e("h3",{attrs:{id:"ts中类的用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ts中类的用法"}},[t._v("#")]),t._v(" ts中类的用法")]),t._v(" "),e("p",[t._v("ts中我们必须要知道的三个修饰符：")]),t._v(" "),e("ul",[e("li",[t._v("public     公有的，在子类中或其他任何地方都可以被访问到")]),t._v(" "),e("li",[t._v("protected  受保护的，在声明它的类中或子类中可以访问，其他任何地方都不能被访问")]),t._v(" "),e("li",[t._v("private    私有的，只有在声明它的类中能访问，其他任何地方都不能被访问")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Person{\n\tpublic name:string;\n\tprivate salary:number;\n\tprotected age:number;\n\tconstructor(name:string, age:number, salary:number) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.salary = salary;\n\t}\n}\nclass Child extends Person{\n\tconstructor(name:string, age:number, salary:number) {\n\t\tsuper(name, age, salary);\n\t}\n\tdescription() {\n\t\tconsole.log(this.name);\n\t\tconsole.log(this.age);\n\t\t// 这里访问this.salary 会报错，因为salary是私有的\n\t}\n}\nlet child = new Child('小明', 18, 10000)\nconsole.log(child.name)\n// 这里访问child.age和child.salary会报错，因为age是受保护的，salary是私有的\n")])])]),e("h3",{attrs:{id:"类的readonly"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类的readonly"}},[t._v("#")]),t._v(" 类的readonly")]),t._v(" "),e("p",[e("code",[t._v("readonly")]),t._v(" 修饰的变量只能在 "),e("code",[t._v("构造函数")]),t._v(" 中初始化, ts允许将 "),e("code",[t._v("interface")]),t._v("、"),e("code",[t._v("type")]),t._v("、"),e("code",[t._v("class")]),t._v(" 上的属性标识为"),e("code",[t._v("readonly")]),t._v("。其实际上只在编译阶段进行代码检查，而 "),e("code",[t._v("const")]),t._v(" 则会在运行时进行检查。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Animal{\n\tpublic readonly name:string;\n\tconstructor(name:string) {\n\t\tthis.name = name;\n\t}\n\tsetName(name) {\n\t\t// 此处会报错，因为name是只读属性\n\t\tthis.name = name;\n\t}\n}\n")])])]),e("h3",{attrs:{id:"抽象类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[t._v("#")]),t._v(" 抽象类")]),t._v(" "),e("p",[t._v("ts中使用 "),e("code",[t._v("abstract")]),t._v(" 来定义抽象类和抽象方法。")]),t._v(" "),e("ul",[e("li",[t._v("抽象类不能被实例化，但是可以被继承")]),t._v(" "),e("li",[t._v("抽象方法必须在子类中实现")])])])}),[],!1,null,null,null);a.default=n.exports}}]);