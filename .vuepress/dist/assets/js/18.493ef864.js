(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{673:function(e,t,s){"use strict";s.r(t);var r=s(49),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h3",{attrs:{id:"promise实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise实现"}},[e._v("#")]),e._v(" Promise实现")]),e._v(" "),s("img",{attrs:{src:"/promise.jpg",height:"410",width:"auto"}}),e._v(" "),s("p",[e._v("摘要： 在很久很久以前，"),s("code",[e._v("Promise")]),e._v("还没有来到这个世上。那时森林里的有这样一群攻城狮，他们饱受回调地狱（回调金字塔）的摧残，苦不堪言。直到有一天，一位不愿意留下姓名的特工横空出世，将他们从回调地狱中解救了出来，代号"),s("code",[e._v("Promise")]),e._v("。自此，很多人都踏上了寻找"),s("code",[e._v("Promise")]),e._v("的道路，我亦如此...\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/28/164dec02da1bdbfe?w=82&h=62&f=gif&s=129324",alt:""}})]),e._v(" "),s("p",[e._v("友情提醒： 本文使用ES6实现的"),s("code",[e._v("Promise")]),e._v("，不会的童鞋们请自行脑补！What？这位同学你竟然不知道ES6，好的，放学了请不要走，我们单独交流一下......")]),e._v(" "),s("h3",{attrs:{id:"回调地狱-vs-promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回调地狱-vs-promise"}},[e._v("#")]),e._v(" 回调地狱 VS Promise")]),e._v(" "),s("p",[e._v("就拿"),s("code",[e._v("fs")]),e._v("（node的核心包）来说吧，假如我们需要同时请求"),s("code",[e._v("a.txt")]),e._v("和"),s("code",[e._v("b.txt")]),e._v("中的数据，然后对数据进行操作。这种需求在我们的开发中也经常遇到哦！")]),e._v(" "),s("ul",[s("li",[e._v("曾经的回调地狱")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("let fs = require('fs');\nlet arr = [];\nfs.readFile('a.txt','utf8',function(err,data){\n  arr.push(data);\n  fs.readFile('b.txt','utf8',function(err,data){\n    arr.push(data);\n    // 如果需要把更多的文件数据，那滋味不敢想象\n    console.log(arr); \n  })\n})\n")])])]),s("ul",[s("li",[e._v("现在的Promise")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("let fs = require('fs');\nfunction read(url,coding){ // 首先我们对fs.readFile()进行promise封装\n  return new Promise((resolve,reject)=>{\n    fs.readFile(url,coding,function(err,data){\n      if(err) reject(err);\n      resolve(data);\n    })\n  })\n}\nPromise.all([read('a.txt','utf8'),read('b.txt','utf8')]).then(data=>{\n  // 这里我们就可以直接操作请求到的两个文件的数据了,Promise还很贴心的返回了一个数组\n  console.log(data);  \n})\n")])])]),s("p",[e._v("相比较之下，"),s("code",[e._v("Promise")]),e._v("和回调地狱的战争起初就不是一个等级的呀，回调地狱听起来强大，但实则一点不经揍啊！"),s("code",[e._v("Promise")]),e._v("此时的内心应该是这样的：\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/28/164dec2c134f179b?w=140&h=134&f=jpeg&s=5307",alt:""}})]),e._v(" "),s("h3",{attrs:{id:"promise之自己实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise之自己实现"}},[e._v("#")]),e._v(" Promise之自己实现")]),e._v(" "),s("p",[e._v("看到这里，相信大家都很想知道Promise的核心实现是什么？接下来，请小伙伴们不要闭眼，看这里，看这里！我便说说我是如何在寻找"),s("code",[e._v("Promise")]),e._v("的道路上一条道走到黑的。（这标题起的，笑出猪叫声）")]),e._v(" "),s("h3",{attrs:{id:"_1、promise-类封装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、promise-类封装"}},[e._v("#")]),e._v(" 1、Promise 类封装")]),e._v(" "),s("p",[e._v("起初，我发现Promise是可以被new的，说明Promise 的出身是一个类啊，这可是一条很有价值的线索啊。（大家都知道，还用你说）")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n  constructor(executor) { // executor是new Promise的参数\n    this.status = 'pending'; // 保存状态\n    this.reason = undefined; // 失败的原因\n    this.value = undefined; // 成功的结果\n    let resolve = (value)=> {\n      if(this.status === 'pending'){\n        this.status = 'resolved';\n        this.value = value;\n      }\n    }\n    let reject = (reason)=>{\n      if(this.status === 'pending'){\n        this.status = 'rejected';\n        this.reason = reason;\n      }\n    }\n    try {\n      executor(resolve, reject); // 执行器       \n    } catch (e) {\n      reject(e);\n    }\n  }\n  // 定义实例上的then方法，then调用的时候都是异步调用的 \n  then(onFulfilled, onRejected) {\n    if(this.status === 'resolved'){ // status状态改变时执行onFulFilled\n      onFulfilled(this.value);\n    }\n    if(this.status === 'rejected'){ // status状态改变时执行onFulFilled\n      onRejected(this.reason);\n    }\n  }\n}  \n")])])]),s("p",[e._v("这怎么仅仅一条线索就写出来这么东东呀，真让人摸不着头脑！别急，听我慢慢道来：")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("executor")]),e._v("：执行器，默认是new的时候就自动执行,executor的执行是同步的，为什么要try一下呢，executor执行时如果"),s("code",[e._v("throw new Error('error')")]),e._v("，直接走reject")]),e._v(" "),s("li",[s("code",[e._v("resolve, reject")]),e._v("：定义了"),s("code",[e._v("executor")]),e._v("的"),s("code",[e._v("resolve")]),e._v("成功的回调函数和"),s("code",[e._v("reject")]),e._v("失败的回调函数两个参数")]),e._v(" "),s("li",[s("code",[e._v("reason,value")]),e._v("：分别代表了成功返回的值和失败的原因")]),e._v(" "),s("li",[s("code",[e._v("status")]),e._v("：保存了"),s("code",[e._v("Promise")]),e._v("的三种状态"),s("code",[e._v("pending")]),e._v("（等待态），"),s("code",[e._v("fulfilled")]),e._v("(成功态)，"),s("code",[e._v("rejected")]),e._v("(失败态)\n"),s("ul",[s("li",[e._v("当一个"),s("code",[e._v("promise")]),e._v("的状态处于"),s("code",[e._v("pending")]),e._v("时，它可以过渡到"),s("code",[e._v("fulfilled")]),e._v("或者"),s("code",[e._v("ejected")])]),e._v(" "),s("li",[e._v("当一个promise的状态处于"),s("code",[e._v("fulfilled")]),e._v("时或者"),s("code",[e._v("rejected")]),e._v("时，不能再过渡到其他任何状态")])])]),e._v(" "),s("li",[s("code",[e._v("then")]),e._v("函数： 因"),s("code",[e._v("Promise")]),e._v("是可以链式调用的，说明"),s("code",[e._v("then")]),e._v("函数是定义在"),s("code",[e._v("Promise")]),e._v("类的原型"),s("code",[e._v("Prototype")]),e._v("上的。")])]),e._v(" "),s("blockquote",[s("p",[e._v("这样我们就成功处理了同步情况下的"),s("code",[e._v("Promise")]),e._v(",是不是觉得自己已经追寻到"),s("code",[e._v("Promise")]),e._v("的终极力量了呢。（抽根烟，平复下躁动的心情）")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/28/164e0356dc8a4c65?w=120&h=117&f=jpeg&s=24937",alt:""}})]),e._v(" "),s("h3",{attrs:{id:"_2、promise异步的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、promise异步的实现"}},[e._v("#")]),e._v(" 2、Promise异步的实现")]),e._v(" "),s("p",[e._v("在我们平时的开发中，往往异步代码比较多，异步执行需要，然"),s("code",[e._v("而Promise")]),e._v("的"),s("code",[e._v("executor")]),e._v("执行器又是同步执行的，它不等我们怎么办呢，好着急有木有。\n我们在上面代码的基础上新增如下几行代码：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class Promise {\n  constructor(executor) {\n    this.onResolvedCallbacks = []; // 保存成功的回调\n    this.onRejectedCallbacks = []; // 保存失败的回调\n    let resolve = (value)=> {\n      if(this.status === 'pending'){\n        this.status = 'resolved';\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn=>fn());\n      }\n    }\n    let reject = (reason)=>{\n      if(this.status === 'pending'){\n        this.status = 'rejected';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn=>fn());\n      }\n    }\n  }\n  then(onFulfilled, onRejected) { \n    if(this.status === 'pending'){\n      this.onResolvedCallbacks.push(()=>{\n          onFulfilled(this.value);\n        });\n      this.onRejectedCallbacks.push(()=>{\n          onRejected(this.reason);\n        });\n      });\n    }\n  }\n}\n")])])]),s("p",[e._v("当出现异步代码时，"),s("code",[e._v("status")]),e._v("的状态还是"),s("code",[e._v("pending")]),e._v("，我们可以先把"),s("code",[e._v("then")]),e._v("函数中成功和失败的回调保存下来，等到异步代码执行完成后，"),s("code",[e._v("status")]),e._v("的状态改变了，我们再去依次执行保存下来的回调函数。")]),e._v(" "),s("p",[e._v("看到这里，如果觉得自己已经基本掌握"),s("code",[e._v("Promise")]),e._v("的实现，只能说尔等对"),s("code",[e._v("Promise")]),e._v("的核心力量一无所知。（别废话，赶紧写）好的，各位大佬！")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/28/164e04910a8a27e0?w=141&h=53&f=gif&s=11155",alt:""}})]),e._v(" "),s("h3",{attrs:{id:"_3、promise之链式调用的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、promise之链式调用的实现"}},[e._v("#")]),e._v(" 3、Promise之链式调用的实现")]),e._v(" "),s("p",[e._v("在开始实现之前呢，我们先来看一下如下代码：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//  这里的Promise是ES6封装好的，并不是我们自己实现的 \nlet promise = new Promise((resolve,reject)=>{ \n  resolve('123');\n})\nlet promise2 = promise.then((data)=>{\n  throw new Error('error');\n})\npromise2.then((data)=>{\n  console.log(data);\n},(err)=>{\n  console.log(err); // 这里输出了error\n})\n")])])]),s("blockquote",[s("p",[e._v("上面代码说明"),s("code",[e._v("then")]),e._v("函数执行后返回的"),s("code",[e._v("promise2")]),e._v("实例并不是"),s("code",[e._v("promise")]),e._v("实例，说明返回值不是"),s("code",[e._v("this")]),e._v("，因为"),s("code",[e._v("promise")]),e._v("不能即调用成功后不能再走失败，所以"),s("code",[e._v("then")]),e._v("函数执行后返回的"),s("code",[e._v("promise2")]),e._v("是一个新的"),s("code",[e._v("promise")]),e._v("实例。（跟jQuery的链式调用不一样哦）")])]),e._v(" "),s("p",[s("code",[e._v("Promise")]),e._v("的"),s("code",[e._v("constructor")]),e._v("的代码不需要改变，只需要对"),s("code",[e._v("then")]),e._v("函数进行再次封装：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("then(onFulfilled, onRejected) {\n    // onFulfilled和onRejected可能没传\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value=>value;\n    onRejected = typeof onRejected === 'function' ? onRejected : (err)=>{throw err};\n    let promise2; // 需要每次调用then方法时，都需要返回新的promise\n    promise2 = new Promise((resolve, reject)=>{\n      if(this.status === 'resolved'){\n        setTimeout(()=>{\n          try {\n            let x = onFulfilled(this.value); \n            // 执行完当前回调后返回的结果可能还是个promise\n            resolvePromise(promise2,x,resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        },0)\n      }\n      if(this.status === 'rejected'){\n        setTimeout(()=>{\n          try {\n            let x = onRejected(this.reason);\n            resolvePromise(promise2,x,resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        },0) \n      }\n      if(this.status === 'pending'){\n        this.onResolvedCallbacks.push(()=>{\n          setTimeout(()=>{\n            try {\n              let x = onFulfilled(this.value);\n              resolvePromise(promise2,x,resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          },0)\n        });\n        this.onRejectedCallbacks.push(()=>{\n          setTimeout(()=>{\n            try {\n              let x = onRejected(this.reason);\n              resolvePromise(promise2,x,resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          },0)\n        });\n      }\n    })\n    return promise2;\n  }\n")])])]),s("ul",[s("li",[s("code",[e._v("onFulfilled,onRejected")]),e._v("：当没有传的时候，需要做的处理")]),e._v(" "),s("li",[s("code",[e._v("promise2")]),e._v("："),s("code",[e._v("then")]),e._v("函数的返回值是一个新的promise")]),e._v(" "),s("li",[s("code",[e._v("setTimeout")]),e._v("：("),s("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise/A+规范"),s("OutboundLink")],1),e._v(")要求"),s("code",[e._v("then")]),e._v("函数必须是异步的，当然原生的Promise实现并不是用的setTimeout，而是一个微任务")]),e._v(" "),s("li",[s("code",[e._v("resolvePromise")]),e._v("：封装"),s("code",[e._v("resolvePromise")]),e._v("方法，当then函数中的成功或者失败函数返回值x可能还是个promise")])]),e._v(" "),s("p",[e._v("定义的resolvePromise方法：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("let resolvePromise = (promise2,x,resolve, reject)=>{\n  let called;\n  // promise2和函数的返回值是同一个\n  if(promise2 === x){\n    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'));\n  }\n  if(x!==null && (typeof x === 'object' || typeof x === 'function')){\n    try {\n      let then = x.then;\n      if(typeof then === 'function'){\n        then.call(x,(y)=>{\n          if(called) return;\n          called = true;\n          resolvePromise(promise2,y,resolve, reject);// 递归处理，直到y是一个普通值\n        },(err)=>{\n          if(called) return;\n          called = true;\n          reject(err);\n        })\n      }else{ // then如果是一个常量\n        if(called) return;\n        called = true;\n        resolve(x);\n      }\n    } catch (e) {\n      if(called) return;\n      called = true;\n      reject(e);\n    }\n  }else{ // x如果是一个常量\n    if(called) return;\n    called = true;\n    resolve(x);\n  }\n}\n")])])]),s("ul",[s("li",[e._v("四个参数："),s("code",[e._v("promise2")]),e._v(" （then函数的返回值，是一个新的promise）\n"),s("code",[e._v("x")]),e._v("（then中成功后者失败函数的返回值）"),s("code",[e._v("resolve")]),e._v("（promise2的resolve）"),s("code",[e._v("reject")]),e._v("（promise2的reject）")]),e._v(" "),s("li",[s("code",[e._v("called")]),e._v("： 加了"),s("code",[e._v("called")]),e._v("判断，防止多次调用，因为这里的逻辑不单单是自己的，还有别人的，别人的"),s("code",[e._v("promise")]),e._v("可能即会调用成功也会调用失败")]),e._v(" "),s("li",[s("code",[e._v("let then = x.then")]),e._v("："),s("code",[e._v("x")]),e._v("可能还是一个"),s("code",[e._v("promise")]),e._v("，那么就让这个"),s("code",[e._v("Promise")]),e._v("执行")])]),e._v(" "),s("p",[e._v("至此，我们终于追寻到了"),s("code",[e._v("promise")]),e._v("的核心力量所在。来，让我们小小的庆贺一下：\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/28/164e10d7fa8aa3ee?w=80&h=65&f=gif&s=16293",alt:""}})]),e._v(" "),s("h3",{attrs:{id:"_3、promise之类上的方法实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、promise之类上的方法实现"}},[e._v("#")]),e._v(" 3、Promise之类上的方法实现")]),e._v(" "),s("p",[e._v("当然，我们已经初步了解了"),s("code",[e._v("promise")]),e._v("的核心力量，在我们开发的过程中，除了then方法，也会使用它的一些其他常用的方法，就像一位身经百战的特工，你除了会用刀，还要会用枪不是。我们在Promise类上定义它们：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("static resolve(value){\n    return new Promise((resolve,reject)=>{\n      resolve(value);\n    })\n  }\n  static reject(reason){\n    return new Promise((resolve,reject)=>{\n      reject(reason);\n    })\n  }\n  static all(promises){\n    return new Promise((resolve,reject)=>{\n      let arr = [];\n      let i = 0;\n      let processData = (index,data)=>{\n        arr[index] = data;\n        if(++i === promises.length){\n          resolve(arr);\n        }\n      }\n      for(let i = 0; i< promises.length; i++){\n        promises[i].then(data=>{\n          processData(i,data);\n        },reject);\n      }\n    })\n  }\n  static race(promises){\n    return new Promise((resolve,reject)=>{\n      for(let i = 0; i< promises.length; i++){\n        promises[i].then(resolve,reject);\n      }\n    })\n  }\n  catch(onRejected){\n    return this.then(null,onRejected);\n  }\n")])])]),s("blockquote",[s("p",[e._v("相信resolve，reject，all,race这四个类上的方法和catch这个原型的方法大家都已经很熟悉了，我就不过多的啰嗦了。")])]),e._v(" "),s("p",[e._v("因为，我实在是编不下去了，我还有更重要的事情要去做：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/28/164e1190f28b2b4f?w=198&h=128&f=jpeg&s=6547",alt:""}})]),e._v(" "),s("p",[e._v("结语： 花了很久写的这篇文章，如果这篇文章令你或多或少有些收获，请不要吝啬你的赞美（点个赞再走吗，小哥哥小姐姐），如果有写的不对的地方，也希望各位大佬能不吝指教，万分感谢！原创文章，转载请注明出处！")])])}),[],!1,null,null,null);t.default=n.exports}}]);